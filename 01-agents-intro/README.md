# AI Agents实战项目第1篇：从传统工具到决策系统的演进

## 写在前面

欢迎来到"AI Agents(智能体)实战项目"，本项目是在 LangChain 官方的教程 [Agents From Scratch](https://github.com/langchain-ai/agents-from-scratch) 演进而来，并在AI辅助下完成，旨在为大家提供一个基础的、实用的、连贯的实战项目。如果你对AI智能体这个概念还不太清楚，或者想了解它能为我们带来什么价值，这个系列会为你提供一个清晰的学习路径。所有的文章和代码都是开源的，地址为：**https://github.com/simfeng/agents-from-scratch**，欢迎 Star。

整个实战项目大概会有7-10节内容，每节内容都会有一篇文章和一个可直接运行的notebook，如果有必要的话，还会有完整的项目文件。我们将从基础概念开始，逐步引导你构建实用的AI智能体。

本节内容notebook地址为：https://github.com/simfeng/agents-from-scratch/blob/main/01-agents-intro/notebook.ipynb

## 目录

- [什么是智能体？一个让人意外的答案](#什么是智能体一个让人意外的答案)
  - [从你最熟悉的软件说起](#从你最熟悉的软件说起)
  - [传统工具的"智商"有多高？](#传统工具的智商有多高)
  - [AI智能体：给工具装上"大脑"](#ai智能体给工具装上大脑)
- [开始动手之前：先想清楚要做什么](#开始动手之前先想清楚要做什么)
- [技术演进之旅：从聊天机器人到智能助手](#技术演进之旅从聊天机器人到智能助手)
  - [第一阶段：Chat Models - 会聊天的AI](#第一阶段chat-models---会聊天的ai)
  - [第二阶段：Tools - 给AI装上"手脚"](#第二阶段tools---给ai装上手脚)
  - [第三阶段：Workflows - 让AI学会制定计划](#第三阶段workflows---让ai学会制定计划)
  - [第四阶段：Agents - 真正的AI助手诞生了](#第四阶段agents---真正的ai助手诞生了)
- [实战选择指南：我应该用哪种方案？](#实战选择指南我应该用哪种方案)
  - [根据任务复杂度来选择](#根据任务复杂度来选择)
  - [根据控制需求来选择](#根据控制需求来选择)
  - [根据开发阶段来选择](#根据开发阶段来选择)
- [给新手的实用建议](#给新手的实用建议)
  - [工具设计的基本原则](#工具设计的基本原则)
  - [与AI沟通的技巧](#与ai沟通的技巧)
  - [测试你的AI助手](#测试你的ai助手)
- [总结](#总结)
  - [我们发现的核心要点](#我们发现的核心要点)
  - [你现在掌握的知识](#你现在掌握的知识)
  - [下一节：LangGraph的深度探索](#下一节langgraph的深度探索)


## 什么是智能体？一个让人意外的答案

### 从你最熟悉的软件说起


在今天这篇开篇文章中，我想先和你探讨一个值得思考的问题：你每天使用的软件，比如微信、浏览器、音乐播放器，它们可以被称为"Agents(智能体)"吗？

如果按照Agent这个词的字面意思——"一个可以执行任务的实体"——来看，微信确实符合这个定义。它能帮你发消息、打电话、支付。不仅是微信，你手机里的每个App其实都可以算作Agent：

- **浏览器**：网络世界的向导，帮你找到需要的信息
- **打车软件**：出行助手，帮你找到最近的司机
- **音乐播放器**：个人音乐管理器，播放你喜欢的歌曲

这样看来似乎很合理。但这里有个值得深思的问题——如果这些软件都算是"智能体"，那为什么直到这两年，"AI智能体"这个概念才开始受到关注呢？

答案在于：**这些传统软件缺少了最关键的组件——"大脑"**。

### 传统工具的"智商"有多高？

让我们通过一个具体例子来理解这个问题。当你在浏览器中输入"python教程"并按下回车时，浏览器会做什么？

它会按照指令搜索"python教程"，然后把结果展示给你。但它不会询问：
- "你是想学编程语言Python，还是想了解蟒蛇（python的中文意思是蟒蛇）？"
- "你是初学者还是有一定基础？"
- "你更喜欢视频教程还是文字教程？"

这就像是一个严格按照指令执行但缺乏灵活性的助手。你说什么，它就做什么，不会主动思考。

再看看打车软件，当你点击"叫车"时，它会按照预设的算法为你匹配司机。但它不会根据你今天的心情、天气情况、或者你的历史偏好来主动调整服务策略。

**这就是传统工具的本质：它们是基于预设逻辑的执行者，而不是具备思考能力的决策者。**

### AI智能体：给工具装上"大脑"

那么，是什么改变了这一切呢？答案是大语言模型（Large Language Model, LLM）的出现。

设想一下，如果我们给传统的工具装上一个"大脑"，会发生什么？这个"大脑"可以：
- 理解你的真实意图
- 分析当前的情况
- 制定执行策略
- 选择合适的工具
- 根据结果调整下一步行动

这就是AI智能体的核心理念：

> **让LLM充当"大脑"，统筹调度那些原本只会按程序执行的工具。**

如果用公式来表示这种变化：
- **传统工具**：输入 → 固定规则 → 输出
- **AI智能体**：输入 → LLM分析思考 → 选择工具 → 执行 → 评估结果 → 输出

这种变化带来的不仅仅是功能的增强，更是从"被动执行"到"主动思考"的根本转变。

## 开始动手之前：先想清楚要做什么

现在你已经理解了AI智能体的基本概念，可能想要开始构建一个。在此之前，让我分享一个重要的经验：

> **构建智能体的第一步，不是写代码，而是明确你要让它完成什么任务。**

注意，这里我说的是"完成什么任务"，是你想要的结果，而不是你告诉他中间的步骤该怎么做。

任务导向的思维方式会让你的智能体更加实用和可控。就像你委托一个助手，你会告诉他"帮我整理好这些文件"，而不是"你要先把文件按类型分类，接着。。。"。

## 技术演进之旅：从聊天机器人到智能助手

理论部分已经介绍得差不多了，现在让我们进入实践环节——动手构建。

我将带你了解一个完整的技术演进过程，看看AI应用是如何从简单的聊天机器人逐步发展成真正智能的助手的。这个过程就像观察一个系统的成长，每个阶段都有其独特的特点。

我们会用到LangChain和LangGraph这两个框架。如果你之前没有接触过，不用担心，我会逐步为你介绍。

### 第一阶段：Chat Models - 会聊天的AI

让我们从最基础的开始——一个只会聊天的AI。这是AI世界的"Hello World"，简单但是必要的第一步，是基于大语言模型的一个应用。

Chat Models 是 LangChain 中对大语言模型（LLM）的统一称谓，比如GPT、Claude、Qwen、DeepSeek等。它们的工作方式很直接：你给它一段文字，它给你回复一段文字。

#### 环境搭建

下面这部分代码介绍了在 LangChain 中如何初始化一个聊天模型。

```python
import os
from dotenv import load_dotenv
from langchain.chat_models import init_chat_model

# 加载配置文件
load_dotenv("../.env", override=True)
model_name = os.getenv("OPENAI_MODEL")
model_provider = os.getenv("MODEL_PROVIDER")

# 初始化模型
llm = init_chat_model(model_name, model_provider=model_provider, temperature=0)
```

#### 两种和AI对话的方式

LangChain提供了两种和AI对话的方式，分别是：

**方式1：一问一答模式 invoke**
```python
# 问一个问题，等完整的回答
result = llm.invoke('什么是智能体？')
print(result.content)  # AI会给你一个完整的回答
```

**方式2：流式对话模式 stream**
```python
# 像聊天一样，AI逐字回复
for chunk in llm.stream("什么是智能体？"):
    print(chunk.content, end="")  # 你会看到AI逐字输出回答
```

#### 这个阶段的局限性

现在我们有了一个会聊天的AI，但它就像一个只能提供理论知识的顾问：
- ✅ 能回答各种问题
- ❌ 不能帮你发邮件
- ❌ 不能帮你查天气
- ❌ 不能帮你订外卖

换句话说，它只能"说"，不能"做"。这就引出了我们的下一个阶段——给AI装上"手脚"。

### 第二阶段：Tools - 给AI装上"手脚"

第一阶段基于LLM的应用，只会"说"不会"做"。现在让我们给它装上"手脚"——也就是工具（Tools）。

设想一下，如果你有一个非常聪明的朋友，但他被限制在一个房间里，只能通过对讲机和你交流。现在，我们要给他一些"遥控器"，让他可以帮你做实际的事情——发邮件、查天气、订外卖等等。

#### 工具是怎么工作的？

在AI智能体的世界里，分工很明确：
- **LLM的工作**：思考"我应该用什么工具？怎么用？"
- **工具的工作**：按照指令执行具体的操作
- **整个流程**：LLM动脑 → 选择工具 → 工具干活 → 返回结果

这就像你是一个项目经理（LLM），手下有各种专业的员工（工具），你负责决策，他们负责执行。

#### 创建第一个工具

LangChain让创建工具变得很简单，通过 `@tool` 装饰器来实现：

```python
from langchain.tools import tool

@tool
def write_email(to: str, subject: str, content: str) -> str:
    """撰写并发送邮件"""
    return f"邮件已发送给 {to}，主题为 {subject}，内容为 {content}"

# 查看这个工具的信息
print(f"工具名称: {write_email.name}")        # write_email
print(f"工具描述: {write_email.description}")  # 撰写并发送邮件
print(f"工具参数: {write_email.args}")         # 参数信息
```

通过 `@tool` 定义的函数，LangChain 会将函数的 `name`、`description`、`args` 等信息提取出来，作为提示词传给 LLM。

#### 让AI学会使用工具

现在我们有了工具，但AI还不知道怎么用。我们需要教会它，这个过程分为三个步骤：

**步骤1：告诉AI有哪些工具可以用**

```python
# 为AI提供工具箱
model_with_tools = llm.bind_tools(
    [write_email],
    tool_choice="any",  # 告诉AI："你必须使用工具"
    parallel_tool_calls=False  # "一次只能用一个工具"
)
```

**步骤2：让AI做决定**

```python
# 给AI一个任务，观察它的选择
output = model_with_tools.invoke(
    "写一封邮件给张三，主题是关于项目进展，内容是：我们正在按照计划推进项目，预计下周完成。"
)

# 查看AI的决定
print("AI选择了:", output.tool_calls[0]['name'])  # write_email
print("AI准备的参数:", output.tool_calls[0]['args'])
```

**步骤3：执行AI的决定**

```python
# 获取AI准备的参数
args = output.tool_calls[0]['args']
# 可能是这样的：{'to': '张三', 'subject': '关于项目进展', 'content': '我们正在按照计划推进项目，预计下周完成。'}

# 执行工具
result = write_email.invoke(args)
print(result)  # 邮件已发送给 张三，主题为 关于项目进展，内容为 我们正在按照计划推进项目，预计下周完成。
```

#### 这个过程到底发生了什么？

让我们通过一个具体例子来理解：

1. **你说**："我想给张三发个邮件说项目进展"
2. **AI想**："用户想发邮件，我有write_email这个工具，需要收件人、主题、内容三个参数"
3. **AI决定**："我要用write_email工具，参数是to='张三', subject='关于项目进展', content='我们正在按照计划推进项目，预计下周完成。'"
4. **工具执行**："邮件发送完成"

#### 这个阶段的特点

现在我们的AI已经升级了，它可以：
- ✅ 理解你的意图
- ✅ 选择合适的工具
- ✅ 执行具体的任务

但是，它还有一个限制：**只能做一件事就结束了**。如果你想让它发完邮件后再做其他事情，它就不知道该怎么办了。这就引出了我们的下一个阶段——让AI学会制定计划。

### 第三阶段：Workflows - 让AI学会制定计划

第二阶段的AI只能做一件事就结束了。现在让我们教会它制定计划，根据不同情况选择不同的行动路径。

设想一下，你有一个助手，你对他说："帮我处理一下今天的工作"。一个聪明的助手会先询问："你今天主要想做什么？回复邮件？准备会议？还是写报告？"然后根据你的回答选择不同的工作流程。

这就是Workflows的核心思想——**给AI一个决策树，让它根据情况选择不同的路径**。

#### Workflows比单纯的工具调用强在哪里？

让我们对比一下：

**第二阶段（单纯工具调用）**：
- 你："发邮件给张三"
- AI："好的，邮件发送完成"
- 结束

**第三阶段（Workflows）**：
- 你："处理一下工作邮件"
- AI："让我先看看...这是要回复邮件还是发送新邮件？"
- AI："看起来是要回复，我来帮你处理"
- AI："邮件回复完成，还需要我做其他的吗？"

可以看到，Workflows让AI有了**判断能力**和**规划能力**。

#### Workflows是怎么工作的？

一个典型的Workflow就像一个流程图：

1. **第一步：分析情况**
   - 用户说了什么？
   - 当前是什么情况？
   - 应该走哪条路？

2. **第二步：选择路径**
   - 如果是A情况 → 执行A流程
   - 如果是B情况 → 执行B流程
   - 如果是C情况 → 执行C流程

3. **第三步：执行具体操作**
   - 调用相应的工具
   - 完成具体任务

#### 智能程度上的权衡

随着我们的AI越来越智能，我们面临一个需要权衡的问题：

- **第一阶段（Chat Models）**：完全可预测，但只能聊天
- **第二阶段（Tools）**：基本可预测，能做具体事情
- **第三阶段（Workflows）**：部分可预测，能根据情况调整
- **第四阶段（Agents）**：不太可预测，但非常灵活

这就像培养一个员工：刚开始你给他详细的操作手册（可预测），慢慢地你只需要告诉他目标，他自己想办法完成（灵活但不可预测）。

### 第四阶段：Agents - 真正的AI助手诞生了

终于到了最重要的阶段。如果说前面三个阶段是在教AI各种技能，那么Agents就是让AI真正"活"起来的阶段。

设想一下，你对一个真正聪明的助手说："帮我准备明天的重要会议"。他不会询问你具体怎么做，而是会自己想办法：
1. 先查看会议议程
2. 准备相关资料
3. 发邮件确认参会人员
4. 预订会议室
5. 准备演示文稿
6. 检查设备是否正常
7. ...

这就是Agent的特点——**它会自己想办法，直到把任务完成为止**。

#### Agents的核心能力

Agent有三个重要特点：

1. **会循环思考**：做完一件事后，会想"接下来该做什么？"
2. **会自我调整**：如果发现当前方法不行，会换个思路
3. **有目标导向**：不会停下来，直到任务真正完成

这就像一个持续工作的问题解决者。

#### 什么时候用Agents，什么时候用Workflows？

这是一个实际的问题。让我们通过具体例子来理解：

**用Workflows的场景**（流程相对固定）：
- "帮我处理客户投诉" → 有标准流程可循
- "每天早上发送日报" → 步骤基本固定
- "审核用户注册信息" → 有明确的检查清单

**用Agents的场景**（需要灵活应变）：
- "帮我策划一个产品发布会" → 需要创造性思考
- "分析竞争对手的策略" → 需要多角度分析
- "解决这个复杂的技术问题" → 可能需要尝试多种方案

简单来说：
- **如果你能提前画出流程图** → 用Workflows
- **如果你也不知道具体怎么做** → 用Agents

## 实战选择指南：我应该用哪种方案？

现在你已经了解了四个阶段的技术，但在实际项目中，应该选择哪种方案呢？这里有一些实用的建议：

### 根据任务复杂度来选择

可以把这个过程想象成招聘不同岗位的员工：

- **简单问答任务**：用Chat Models
  - 类似客服机器人，回答常见问题
  - 例子："我们公司的营业时间是什么？"

- **单一操作任务**：用Tools
  - 类似专业技师，完成一件事
  - 例子："帮我发送这封邮件"

- **多步骤标准流程**：用Workflows
  - 类似有经验的员工，按流程办事
  - 例子："处理新用户注册流程"

- **复杂创造性任务**：用Agents
  - 类似高级顾问，自己想办法解决问题
  - 例子："帮我制定市场推广策略"

### 根据控制需求来选择

- **需要严格控制**：选择Tools或Workflows
  - 适合金融、医疗等对准确性要求极高的场景

- **需要一定灵活性**：选择Workflows
  - 适合大部分商业应用

- **需要最大灵活性**：选择Agents
  - 适合创新型项目和研究场景

### 根据开发阶段来选择

- **刚开始探索**：从Chat Models开始，快速验证想法
- **功能验证**：用Tools实现核心功能
- **产品化**：用Workflows构建稳定的业务流程
- **高级功能**：用Agents处理复杂场景

## 给新手的实用建议

### 工具设计的基本原则

1. **一个工具只做一件事**
   - 不要让一个工具既能发邮件又能查天气
   - 就像厨房里的刀具，每把刀都有专门的用途

2. **给工具写清楚说明**
   - AI需要知道这个工具是干什么的
   - 就像给新员工写岗位职责一样详细

3. **做好错误处理**
   - 工具出错时要有合理的提示
   - 不要让AI无法继续工作

### 与AI沟通的技巧

1. **说话要具体**
   - ❌ "帮我处理邮件"
   - ✅ "帮我回复今天收到的客户咨询邮件"

2. **给出例子**
   - 告诉AI你期望的结果是什么样的
   - 就像给员工看样品一样

3. **设定边界**
   - 明确告诉AI什么能做，什么不能做
   - 避免AI超出预期范围

### 测试你的AI助手

1. **单独测试每个工具**
   - 确保每个工具都能正常工作

2. **测试AI和工具的配合**
   - 看AI是否能正确选择和使用工具

3. **测试完整的用户场景**
   - 模拟真实用户的使用情况

## 总结

我们一起走过了从零构建AI Agents的第一节内容，让我来回顾一下我们都学到了什么：

### 我们发现的核心要点

1. **AI智能体的本质**：其实就是给传统工具装上一个会思考的"大脑"（LLM）
2. **演进的四个阶段**：从只会聊天 → 能使用工具 → 会制定计划 → 完全自主决策
3. **智能与控制的平衡**：越智能的AI越难预测，这是一个需要权衡的问题
4. **选择的智慧**：不同的任务需要不同级别的AI，没有万能的解决方案

### 你现在掌握的知识

通过这篇文章，你现在已经：
- ✅ 理解了AI智能体的本质和价值
- ✅ 掌握了四种不同级别的AI应用方式
- ✅ 学会了如何根据实际需求选择合适的技术方案
- ✅ 获得了构建AI应用的实用建议和最佳实践

### 下一节：LangGraph的深度探索

这只是我们"AI智能体实战项目"系列的第一步。在下一篇文章中，我们将深入LangGraph框架。

